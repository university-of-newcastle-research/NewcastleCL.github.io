---
title: "Simulation and Recovery with PMwG"
author: "Reilly Innes"
date: "17/03/2021"
output: html_document
---

This blog post presents a brief guide on how to create synthetic data, and perform parameter recovery, using the PMwG sampler. Parameter recovery is highly important in cognitive modelling procedures as it provides an indication of parameter identifiability (and in a way, model "power"). Parameter recovery involves creating synthetic data using a likelihood function, checking the synthetic data, performing a sampling regime and then checking the posterior estimates (as well as posterior predictive data). It is an essential step in the modelling process. 


Parameter recovery through simulation allows us to be confident in our models for three reasons. First, it gives us confidence that our model *actually works*, i.e. it runs, it relates to data, it does what it's supposed to do. Secondly, parameter recovery allows us to see whether the parameter values we input are recovered at the end, and this can give us confidence in the reliability of our model. Finally, parameter recovery allows us to test a variety of parameter combinations and models, which can test theory and help us build hypotheses. 

## Synthetic data

Synthetic data is data generated from your model. When simulating this synthetic data, we make a data set that looks just like real data (i.e. same structure), with the aim of later replacing it with real data. We also want this synthetic data to reflect real data - i.e. somewhere in the ballpark of means and variance. When generating synthetic data, we input parameter values that we decide (or could be informed by prior research) and then use a random generator function (like rnorm, rlba or rddm), that takes in these values to create data. 

By creating synthetic data, we are able to control the input parameters, and so we are able to better understand how parameters affect synthetic data - i.e. whether changing given parameters changes output. Secondly, we are able to see if the original values are recovered following sampling, therefore showing how well the model identifies the actual effects. Finally, we can see how well the posterior predictive data fits the synthetic data. Often different parameters may lead to similar patterns in the data (i.e. higher thresholds and higher t0 can show similar increases in rt for accumulator models), so by comparing to the posterior predictive, this can give us an indication of whether our model can tease apart parameter differences. 

Within PMwG, there is an assumed hierarchical structure, with group level (theta) and individual participant level (alpha) values. On each iteration of the sampling process, n particles density are compared (given the data). These particles are drawn from a multivariate normal distribution centered around each participants current particle (with added noise). To create this multivariate normal distribution, the sampler also uses a covariance matrix, which gives insight into the level of covariance between individual parameters. This makes simulating synthetic data for the PMwG sampler slightly more complex, as simulated parameters should also have a covariance structure constraining them. This is shown below. 

In this blog post I will;

 - construct the data structure
 - construct a likelihood function with sampling and density calculation arguments. 
 - create some parameters for the model
 - fill in the values for these parameters
 - constrain by the covariance matrix
 - create data
 - perform parameter recovery.

## Simulation

#### Starting out
First I load in the packages used for this exercise;

```{r setup, include=TRUE, message=FALSE}
library(rtdists)
library(mvtnorm) ## For the multivariate normal.
library(MASS) ## For matrix inverse.
library(MCMCpack)
library(lme4)
library(dplyr)
library(ggplot2)
library(tidyr)
```


#### Data structure

Next, we set up the structure of the data frame to be filled with data. For this exercise, i use 3 conditions, each with 100 trials for 20 participants. You can create whatever data structure you wish, however, it should map to your likelihood function, should be the same as your real data (or at least the parts of your real data used in the likelihood function) and can be any length (but more is better). I do this setup step first as this often assists with writing the likelihood function (i.e. for correct column names and data structure). 

```{r dataSetup, include=TRUE}
n.trials = 100      #number trials per subject per conditions
n.subj = 20         #number of subjects
n.cond = 3          #number of conditions


names=c("subject","rt","resp","condition") #names of columns
data = data.frame(matrix(NA, ncol = length(names), nrow = (n.trials*n.subj*n.cond))) #empty data frame
names(data)=names
data$condition = rep(1:n.cond,times = n.trials) #filling in condition
data$subject = rep(1:n.subj, each = n.trials*n.cond) #filling in subjects
```

#### Construct the model 

Now that the data structure has been created, I need to establish my model. The model I use here is similar to that used in [Chapter 3](https://newcastlecl.github.io/samplerDoc/forstmannChapter.html#writellFunc) of the PMwG Documention. This model is a LBA model which includes 3 different thresholds (differing across conditions).

```{r ll, include=TRUE}

log_likelihood=function(x,data,sample=TRUE) {
  x=exp(x)
  bs=x["A"]+x[c("b1","b2","b3")][data$condition]
  if (sample) { #for sampling
    out=rLBA(n=nrow(data),A=x["A"],b=bs,t0=x["t0"],mean_v=x[c("v1","v2")],sd_v=c(1,1),distribution="norm",silent=TRUE)
  } else { #for calculating density
    out=dLBA(rt=data$rt,response=data$correct,A=x["A"],b=bs,t0=x["t0"],mean_v=x[c("v1","v2")],sd_v=c(1,1),distribution="norm",silent=TRUE)
    bad=(out<1e-10)|(!is.finite(out))
    out[bad]=1e-10
    out=sum(log(out))
  }
  out
}
```

In this example, I use responses "1" and "2", but you can use whatever responses you would prefer (i.e. correct or error etc). Further, you could also use a different model type (i.e. diffusion). 

#### Create model parameters

Next, I create my parameter vector;

```{r pars, include=TRUE}

parameter.names=c("b1","b2","b3", "A","v1","v2","t0")
n.parameters=length(parameter.names)

```

Now i set up a vector of parameter values and a matrix of covariance matrix values. I label these `ptm` and `ptm2`;

```{r fillPars, include=TRUE}
ptm <- array(dim = n.parameters, dimnames = list(parameter.names)) #an empty array where i will put parameter values
pts2 <- array(dim=c(n.parameters,n.parameters), dimnames = list(parameter.names,parameter.names)) #an empty array where i will put the covariance matrix
```


#### Fill in model parameters
I then give start points for my input parameters. Here, I use increments of 0.2 for the threshold parameters. It is important to consider a number of different values to see if, and how, they affect the simulated data (but you can do this later). For example, I may also want to vary t0 or drift rates (i.e. different models) to see if these parameters are also recoverable. 

NOTE: these values are on the log scale (as the likelihood function takes the exponent of these). This is important to note as PMwG draws values along the real number line. 

```{r fillPars2, include=TRUE}

ptm[1:n.parameters]=c(0.1,0.3,0.5,0.4,1.2,0.3,-2) 
exp(ptm)

```

#### Create covariance matrix 

Next, I make the variance of the parameters. I do this in a simple way by taking the absolute value for each parameter and divide by 10 - but you can vary them however you like, for example, there may be covariances that are important to the model. In this example with the LBA, it might be better to put larger correlations between b and t0. 

In this code, SigmaC is a matrix with diagonal of 0.2 (i.e. a correlation of .2 between all parameters), and off diagonal as the variance we just created. I then do sdcor2cov to create a covariance matrix. I do this because, rather than correlation, PMwG expects covariance. You can do the opposite transform to recover these correlations after recovery. 

This step is the tricky part of simulating in PMwG, as we need this correlation structure (which becomes a covariance structure) to constrain parameters.  

```{r covariance, include=TRUE}


vars = abs(ptm)/10 #off diagonal correlations are done as absolute/10
sigmaC = matrix(.2,nrow=length(ptm),ncol=length(ptm)) ###std dev correlation on diagonal - you might think this should be corr = 1, but it's actually the standard deviation 
diag(sigmaC)=sqrt(vars)
sigmaC <- sdcor2cov(sigmaC)
```

#### Create random effects

Finally, I create the subjects random effects. This is a n_parameters * n_subject matrix, so that each subject has a value for each parameter. This is created using rmvnorm, where I do n_subjects of random samples using the mean parameters (ptm) and covariance matrix (sigmaC). **These are the values we wish to recover using the model** (so it's often good to save out ptm, sigmaC and subj_random_effects). 

```{r re, eval=FALSE}

subj_random_effects <- t(mvtnorm::rmvnorm(n.subj,mean=ptm,sigma=sigmaC))

```

```{r re_load, echo=FALSE}

load("~/Documents/Research/Modelling Project/Work/pmwg/Blogs/random_effects.Rdata")
print(subj_random_effects)

```

#### Create data

Using the likelihood function, I now run a for loop to create data and fill that empty matrix we made at the start! The likelihood returns both rt and resp, so the lower two lines fill in the appropriate columns in the data frame. The `for` loop runs for each subject, and so I input the subj_random_effect for each participant and fill the appropriate place in the data structure. 

**NOTE:** It is important to check the data and general trends from the output. This can give an indication of how different parameters and covariance affect the data. 


```{r makeData, eval=FALSE}
for (i in 1:n.subj){
  tmp<- log_likelihood(subj_random_effects[,i],sample=TRUE,data=data[data$subject==i,])
  data$rt[data$subject==i]=tmp$rt
  data$resp[data$subject==i]=tmp$response
}
head(data)
```

```{r load_data, echo=FALSE}

load("~/Documents/Research/Modelling Project/Work/pmwg/Blogs/synth_data.Rdata")
head(data)
```

We now have synthetic data which;
 - is generated using our model
 - uses theta values we input
 - uses a covariance structure we created
 
This means that these objects can be recovered. 

## Recovery

I now run a typical PMwG sampling exercise. Here the likelihood is unchanged from the PMwG documentation. I use broad priors and do not specify any start points. Following the adaptation stage, i take 1000 samples from the posterior. 


**NOTE:** Running this on your own machine may be time consuming (and resource consuming). You may want to run it on a grid or dial down the number of cores used in sampling and wait it out. 


```{r pmwg, eval=FALSE}

library(pmwg)

# Specify the log likelihood function -------------------------------------------

lba_loglike <- function(x, data, sample = FALSE) {
  x <- exp(x)
  if (any(data$rt < x["t0"])) {
    return(-1e10)
  }
  if (sample){
    data$rt=NA
    data$resp = NA
  }
  
  bs <- x["A"] + x[c("b1", "b2", "b3")][data$condition]
  
  if (sample) {
    out <- rtdists::rLBA(n = nrow(data),
                         A = x["A"],
                         b = bs,
                         t0 = x["t0"],
                         mean_v = x[c("v1", "v2")],
                         sd_v = c(1, 1),
                         distribution = "norm",
                         silent = TRUE)
    data$rt <- out$rt
    data$resp <- out$resp
    
  } else {
    out <- rtdists::dLBA(rt = data$rt,
                         response = data$resp,
                         A = x["A"],
                         b = bs,
                         t0 = x["t0"],
                         mean_v = list(x["v1"],x[ "v2"]),
                         sd_v = c(1, 1),
                         distribution = "norm",
                         silent = TRUE)
    bad <- (out < 1e-10) | (!is.finite(out))
    out[bad] <- 1e-10
    out <- sum(log(out))
  }
  if (sample){return(data)}
  if (!sample){return(out)}
}




# Specify the parameters and priors -------------------------------------------

# Vars used for controlling the run
pars <- c("b1","b2","b3", "A","v1","v2","t0")

priors <- list(
  theta_mu_mean = rep(0, length(pars)),
  theta_mu_var = diag(rep(9, length(pars)))) 


# Create the Particle Metropolis within Gibbs sampler object ------------------

sampler <- pmwgs(
  data = data,
  pars = pars,
  prior = priors,
  ll_func = lba_loglike
)


# start the sampler ---------------------------------------------------------

sampler <- init(sampler) # i don't use any start points here


# Sample! -------------------------------------------------------------------

burned <- run_stage(sampler, stage = "burn",iter = 500, particles = 100, n_cores = 16) #epsion will set automatically to 0.5

adapted <- run_stage(burned, stage = "adapt", iter = 5000, particles = 100, n_cores = 16)

sampled <- run_stage(adapted, stage = "sample", iter = 1000, particles = 100, n_cores = 16)

```

```{r load_pmwg, echo=FALSE}
load("~/Documents/Research/Modelling Project/Work/pmwg/Blogs/recovery_samples.Rdata")

```


We now have samples from our model which is fitted to the simulated data! You should check that the sampling process worked well before continuing on. To check this process, see the guide in the [PMwG documentation](https://newcastlecl.github.io/samplerDoc/pmwg-sampler-and-signal-detection-theory.html#check-sampling-process). 

## Checking and Simulating posterior predictive data

We now have 1000 posterior samples. From here, there are several steps we want to take to check how well parameters recover. First, we'll check the mean posterior theta estimates. Then we'll check the alpha (random effects) estimates, before checking the covariance matrix. For extra checking, I'll then simulate data from the posterior to see how well the data recovers. 


#### Checking the theta, alpha and covariance matrix

The first check I do is to see whether our `ptm` values and `subj_random_effect` recovered following simulation and sampling. I first do this at the group (theta) level;

```{r checks, include=TRUE}
theta <- apply(sampled$samples$theta_mu[,sampled$samples$stage=="sample"],1,mean) #gets the 
exp(theta) #done for convenience of interpretation
exp(ptm)
```


And then at the subject (alpha) level;

```{r checks2, include=TRUE}
alpha <- apply(sampled$samples$alpha[,,sampled$samples$stage=="sample"],1:2,mean)
exp(alpha)
exp(subj_random_effects)
```

These seem to recover quite accurately. Next though, we need to check the covariance matrix;

```{r checks_cov, include=TRUE}

sig<-sampled$samples$theta_sig[,,sampled$samples$stage=="sample"]

cov<-apply(sig,3,cov2cor)
cov2<-array(cov, c(length(pars),length(pars),1000)) ##1000 is the length of posterior sampling 
colnames(cov2)<-pars
rownames(cov2)<-pars
apply(cov2,1:2, mean)
cov2cor(sigmaC)

```


#### Simulate Posterior

Following these checks, I simulate posterior predictive data from the posterior model estimates. For simulating from the posterior, I follow a similar method to that shown [here](https://newcastlecl.github.io/samplerDoc/pmwg-sampler-and-signal-detection-theory.html#simulating-posterior-data). First taking some random posterior samples, and then using our likelihood function to simulate data (similar to the earlier synthetic data step). In this example, I use 20 posterior samples (this is a good start - you may want to use more). This means my posterior predictive data will be 20 times the length of my simulated data. 

```{r post, eval=FALSE}
generate.posterior <- function(sampled, n){  #this function uses sampled$ll_func as the likelihood function to sample from
  n.posterior=n # Number of samples from posterior distribution.
  pp.data=list()
  S = sampled$n_subjects
  data=sampled$data
  data$subject<- as.factor(data$subject)
  sampled_stage = length(sampled$samples$stage[sampled$samples$stage=="sample"])
  for (s in 1:S) {
    cat(s," ")
    iterations=round(seq(from=(sampled$samples$idx-sampled_stage) , to=sampled$samples$idx, length.out=n.posterior)) #grab a random iteration of posterior samples
    for (i in 1:length(iterations)) { #for each iteration, generate data
      x <- sampled$samples$alpha[,s,iterations[i]]
      names(x) <- sampled$par_names
      tmp=sampled$ll_func(x=x,data=data[as.integer(as.numeric(data$subject))==s,],sample=TRUE) #this line relies on your LL being setup to generate data
      if (i==1) {
        pp.data[[s]]=cbind(i,tmp)
      } else {
        pp.data[[s]]=rbind(pp.data[[s]],cbind(i,tmp))
      }
    }
    
  }
  return(pp.data)
}

pp.data<-generate.posterior(sampled,20)
tmp=do.call(rbind,pp.data)
glimpse(tmp)

```

```{r post_load, echo=FALSE}
load("~/Documents/Research/Modelling Project/Work/pmwg/Blogs/posterior_samples.Rdata")
glimpse(tmp)

```



Now we have data from the posterior, we can plot this data against our synthetic data. 

```{r graph, include=TRUE, message=FALSE}
#functions to find the 10th, 30th, 50th, 70th and 90th quantiles
q10=function(x) quantile(x,prob=.10,na.rm = TRUE)
q30=function(x) quantile(x,prob=.30,na.rm = TRUE)
q50=function(x) quantile(x,prob=.50,na.rm = TRUE)
q70=function(x) quantile(x,prob=.70,na.rm = TRUE)
q90=function(x) quantile(x,prob=.90,na.rm = TRUE)

#posterior rt data across quantiles
posterior <- tmp %>% group_by(i,condition) %>%
  summarise("0.1"=q10(rt),
            "0.3"=q30(rt),
            "0.5"=q50(rt),
            "0.7"=q70(rt),
            "0.9"=q90(rt))%>%
  ungroup()

#reshape
posterior<-posterior %>%
  pivot_longer(
    cols = starts_with("0"),
    names_to = "quantile",
    names_prefix = "",
    values_to = "rt",
    values_drop_na = TRUE
  )

#synthetic rt data across quantiles
synthetic <- data %>% group_by(condition) %>%
  summarise("0.1"=q10(rt),
            "0.3"=q30(rt),
            "0.5"=q50(rt),
            "0.7"=q70(rt),
            "0.9"=q90(rt))%>%
  ungroup()

#resahpe
synthetic<-synthetic %>%
  pivot_longer(
    cols = starts_with("0"),
    names_to = "quantile",
    names_prefix = "",
    values_to = "rt",
    values_drop_na = TRUE
  )

synthetic$condition<-as.factor(synthetic$condition)
posterior$condition<-as.factor(posterior$condition)

#plot - this is only for RT. Also may want to plot accuracy
ggplot(posterior, aes(x=as.numeric(quantile), y= rt))+
  geom_point(aes(colour = condition))+
  xlab("Quantile")+
  scale_color_manual(values = c("red", "blue", "green"))+
  geom_line(aes(colour = condition))+
  scale_color_manual(values = c("red", "blue", "green"))+
  geom_point(data=synthetic, aes(x=as.numeric(quantile), y= rt, fill = condition), shape = 24, size=3, alpha = .5)+
  theme_bw()+
  scale_fill_manual(values = c("grey", "black", "navy"))


```
 

This graph shows RT on the y-axis across quantiles (x-axis) for both the simulated (grey triangles) and posterior recovery data (shown as coloured dots for each posterior iteration and lines for the means). Here we see the posterior recovered samples appear to match the synthetic data quite well, as we expected.   

## Conclusion

Simulation and recovery practises are important for any modelling exercise. It is important to be familiar with the methods to perform simulation and recovery so you can be confident in your log likelihood function being reliable and valid (in regards to theory). This blog post aimed to explain methods of simulation and recovery for the PMwG package, and provide a framework to allow such practices. 


